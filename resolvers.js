require('dotenv').config();
const neo4j = require('neo4j-driver');

const NEO4J_URI = process.env.NEO4J_URI;
const NEO4J_USERNAME = process.env.NEO4J_USERNAME;
const NEO4J_PASSWORD = process.env.NEO4J_PASSWORD;

const driver = neo4j.driver(NEO4J_URI, neo4j.auth.basic(NEO4J_USERNAME, NEO4J_PASSWORD));
const session = driver.session();
let ingredients = [];
const resolvers = {
    Query: {
        getIngredient: async (parent, { id }) => {
            try {
                // Use a Cypher query to retrieve a specific ingredient by ID
                const result = await session.run('MATCH (i:Ingredient) WHERE id(i) = $id RETURN i', { id: parseInt(id) });
                const foundIngredient = result.records[0].get('i').properties;

                // Retrieve the autogenerated ID
                foundIngredient.id = result.records[0].get('i').identity.low;

                return foundIngredient;
            } catch (error) {
                console.error(error);
                throw new Error('Failed to retrieve ingredient');
            }
        },
        getAllIngredients: async () => {
            try {
                // Use a Cypher query to retrieve all ingredients
                const result = await session.run('MATCH (i:Ingredient) RETURN i');
                return result.records.map(record => {
                    const ingredient = record.get('i').properties;
                    // Retrieve the autogenerated ID
                    ingredient.id = record.get('i').identity.low;
                    return ingredient;
                });
            } catch (error) {
                console.error(error);
                throw new Error('Failed to retrieve ingredients');
            }
        },
    },
    Mutation: {
        createIngredient: async (parent, { name }) => {
            try {
                const result = await session.run('CREATE (i:Ingredient {name: $name}) RETURN i', { name });
                const createdIngredient = result.records[0].get('i').properties;

                // Retrieve the autogenerated ID
                createdIngredient.id = result.records[0].get('i').identity.low;

                // Optionally, you can update your local ingredients array

                ingredients.push(createdIngredient);

                return createdIngredient;
            } catch (error) {
                console.error(error);
                throw new Error('Failed to create ingredient');
            }
        },
        updateIngredient: async (parent, { id, name }) => {
            try {
                const result = await session.run('MATCH (i:Ingredient) WHERE id(i) = $id SET i.name = $name RETURN i', { id: parseInt(id), name });
                const updatedIngredient = result.records[0].get('i').properties;

                // Retrieve the autogenerated ID
                updatedIngredient.id = result.records[0].get('i').identity.low;

                // Optionally, you can update your local ingredients array
                ingredients = ingredients.map(ingredient => {
                    if (ingredient.id === updatedIngredient.id) {
                        return updatedIngredient;
                    }
                    return ingredient;
                });

                return updatedIngredient;
            } catch (error) {
                console.error(error);
                throw new Error('Failed to update ingredient');
            }
        },
        deleteIngredient: async (parent, { id }) => {
            try {
                const result = await session.run('MATCH (i:Ingredient) WHERE id(i) = $id DETACH DELETE i RETURN i', {
                    id: parseInt(id),
                });

                // Check if a record was actually deleted
                if (result.records.length === 0) {
                    throw new Error(`Ingredient with ID ${id} not found`);
                }

                // No need to return the entire ingredient, just return the id
                const deletedIngredientId = result.records[0].get('i').identity.low;

                // Optionally, you can update your local ingredients array
                ingredients = ingredients.filter(ingredient => ingredient.id !== deletedIngredientId);


            } catch (error) {
                console.error(error);
                throw new Error(`Failed to delete ingredient: ${error.message}`);
            }
        },
    },
    Subscription: {
        ingredientAdded: {
            subscribe: () => pubsub.asyncIterator(['INGREDIENT_ADDED']),
        },
    },
};

module.exports = resolvers;
