require('dotenv').config();
const neo4j = require('neo4j-driver');
const { Ingredient } = require('./model/Ingredient');
const { Element } = require('./model/Element');
const { Recipe } = require('./model/Recipe');

const NEO4J_URI = process.env.NEO4J_URI;
const NEO4J_USERNAME = process.env.NEO4J_USERNAME;
const NEO4J_PASSWORD = process.env.NEO4J_PASSWORD;

const driver = neo4j.driver(NEO4J_URI, neo4j.auth.basic(NEO4J_USERNAME, NEO4J_PASSWORD));
const session = driver.session();

const resolvers = {
    Query: {
        getIngredient: async (parent, { id }) => {
            try {
                const result = await session.run('MATCH (i:Ingredient) WHERE id(i) = $id RETURN i', { id: parseInt(id) });
                const singleRecord = result.records[0];
                const ingredient = singleRecord.get(0);
                const ingredientWithId = ingredient.properties;
                ingredientWithId.id = ingredient.identity.toString();
                return ingredientWithId;
            } catch (error) {
                console.error(error);
                throw new Error(`Failed to get ingredient: ${error.message}`);
            }
        },
        getAllIngredients: async () => {
            try {
              const result = await session.run('MATCH (n:Ingredient) RETURN ID(n) AS id, n.name AS name');
              return result.records
                .filter(record => record.get('name') !== null)  // Filter out records with null name
                .map(record => ({
                  id: record.get('id').toString(),
                  name: record.get('name'),
                }));
            } catch (error) {
              console.error(error);
              throw new Error('Failed to get ingredients');
            } finally {
              await session.close();
            }
          },
    },
    Mutation: {
        createIngredient: async (parent, { name }) => {
            try {
                const result = await session.run('CREATE (i:Ingredient {name: $name}) RETURN i', { name });
                const createdIngredient = result.records[0].get('i').properties;

                // Retrieve the autogenerated ID
                createdIngredient.id = result.records[0].get('i').identity.low;

                return createdIngredient;
            } catch (error) {
                console.error(error);
                throw new Error('Failed to create ingredient');
            }
        },
        updateIngredient: async (parent, { id, name }) => {
            try {
                const result = await session.run('MATCH (i:Ingredient) WHERE id(i) = $id SET i.name = $name RETURN i', { id: parseInt(id), name });
                const updatedIngredient = result.records[0].get('i').properties;
                // Retrieve the autogenerated ID
                updatedIngredient.id = result.records[0].get('i').identity.toString();
                
                return updatedIngredient;
            } catch (error) {
                console.error(error);
                throw new Error('Failed to update ingredient');
            }
        },
        deleteIngredient: async (parent, { id }) => {
            try {
                const result = await session.run('MATCH (i:Ingredient) WHERE id(i) = $id DETACH DELETE i RETURN i', {
                    id: parseInt(id),
                });

                // Check if a record was actually deleted
                if (result.records.length === 0) {
                    throw new Error(`Ingredient with ID ${id} not found`);
                }
            } catch (error) {
                console.error(error);
                throw new Error(`Failed to delete ingredient: ${error.message}`);
            }
        },
        createRecipe: async (parent,parameters) => {
            const createRecipeQuery = `
                CREATE (recipe:Recipe {name: $name, instructions: $instructions})
                RETURN recipe`;
            
            try {
                const result = await session.run(createRecipeQuery, parameters);
        
                if (!result.records || result.records.length === 0) {
                    console.error('Failed to create recipe');
                    throw new Error('Failed to create recipe');
                }
        
                const record = result.records[0];
                const recipeNode = record.get('recipe');
                const id = recipeNode.identity.toString();
                const createdRecipe = recipeNode.properties;
                createdRecipe.id = id;
                createdRecipe.elements = []
        
                return createdRecipe;
            } catch (error) {
                console.error(error);
                throw new Error('Failed to create recipe');
            } finally {
                await session.close();
            }
        },                                       
    },
};

module.exports = resolvers;
